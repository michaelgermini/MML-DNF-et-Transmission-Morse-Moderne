# 2.2 Transmission hors‑réseau : Bluetooth, Mesh, radio amateurs

## Au-delà du cloud : Les réseaux décentralisés et autonomes

### La fragilité de l'infrastructure centralisée

Notre société moderne repose sur une **illusion de connectivité permanente** :
- Applications cloud qui supposent une connexion Internet constante
- Téléphones qui deviennent inutiles sans réseau cellulaire
- IoT devices qui cessent de fonctionner en cas de panne

Mais la réalité est différente. Considérons ces scénarios :
- **Catastrophe naturelle** : Ouragans, tremblements de terre coupent les infrastructures
- **Zones rurales** : Absence de couverture réseau sur des milliers de kilomètres
- **Conflits** : Infrastructures intentionnellement détruites
- **Exploration** : Environnements extrêmes (océan, espace, sous-terrain)

Dans ces contextes, notre système DNF-MML-Morse devient non pas une curiosité technique, mais une **nécessité absolue**.

## Bluetooth : La proximité comme atout stratégique

### Au-delà du "pairing" traditionnel

Le Bluetooth moderne (BLE 5.0+) offre des capacités surprenantes pour la transmission hors-réseau :

#### Caractéristiques techniques clés
- **Portée étendue** : Jusqu'à 400 mètres en ligne de vue
- **Basse consommation** : Quelques microwatts en veille
- **Mesh networking** : Routage multi-sauts automatique
- **Broadcasting** : Diffusion à tous les appareils à portée

#### Implémentation DNF sur Bluetooth

```python
class BluetoothDNFLayer:
    def __init__(self):
        self.mesh_network = BluetoothMesh()
        self.advertisement_interval = 100  # ms
        self.max_hops = 10

    def broadcast_fragment(self, fragment, ttl=30):
        """
        Diffusion d'un fragment MML dans le réseau mesh
        """
        packet = DNFPacket(
            content=fragment,
            type='mml_fragment',
            ttl=ttl,
            sender_id=self.get_device_id(),
            timestamp=time.time()
        )

        # Diffusion avec backoff exponentiel
        self.mesh_network.broadcast(packet, backoff_base=1.5)

    def listen_for_fragments(self):
        """
        Écoute active des fragments entrants
        """
        while self.is_active:
            packet = self.mesh_network.receive(timeout=1.0)
            if packet and self.validate_packet(packet):
                self.process_incoming_fragment(packet)

    def find_optimal_relay(self, destination):
        """
        Découverte du meilleur relais via sondage réseau
        """
        probes = []
        for neighbor in self.get_neighbors():
            probe = PingProbe(destination, via=neighbor)
            probes.append(self.send_probe(probe))

        # Analyse des réponses
        best_relay = min(probes, key=lambda p: p.round_trip_time)
        return best_relay.neighbor if best_relay.success else None
```

### Cas d'usage Bluetooth dans DNF

#### 1. Réseaux communautaires locaux
```
Maison A ── Bluetooth ── Maison B ── Bluetooth ── Maison C
   │                        │                        │
 Éolienne                Panneau solaire          Batterie
```
*Partage d'énergie et d'informations dans les communautés rurales*

#### 2. Coordination d'urgence
```
Secours 1 ── Mesh ── Véhicule secours ── Mesh ── Hôpital
    │                    │                       │
Victime 1            Victime 2               Victime 3
```
*Transmission de statuts et coordonnées sans infrastructure*

#### 3. Explorations souterraines
```
Spéléologue A ── Bluetooth ── Robot éclaireur ── Bluetooth ── Base
      │                                              │
 Capteur gaz                                    Centre de contrôle
```
*Communication dans les environnements sans radio*

## Les réseaux Mesh : L'auto-organisation collective

### Principes du mesh networking

Un réseau mesh est un système où **chaque nœud participe activement au routage** :

#### Architecture décentralisée
- **Pas de point central** : Égalité entre tous les participants
- **Auto-découverte** : Nœuds se trouvent et s'organisent automatiquement
- **Auto-guérison** : Reconfiguration automatique en cas de panne
- **Évolutivité** : Ajout de nœuds sans reconfiguration

#### Algorithmes de routage mesh

##### OLSR (Optimized Link State Routing)
- **Proactif** : Maintenance permanente des tables de routage
- **Multi-point relays** : Sélection d'un sous-ensemble de nœuds pour le flooding
- **Calcul de chemins optimaux** : Utilisation de l'algorithme de Dijkstra

##### AODV (Ad hoc On-Demand Distance Vector)
- **Réactif** : Calcul de routes seulement quand nécessaire
- **Découverte par inondation** : Broadcast de paquets de découverte
- **Maintenance incrémentale** : Mise à jour des routes selon l'usage

##### BATMAN-adv (Better Approach To Mobile Adhoc Networking)
- **Originator messages** : Chaque nœud annonce ses voisins directs
- **Classement par qualité** : Évaluation des liens par perte de paquets
- **Routage de proximité** : Choix du chemin avec le moins de sauts

### Implémentation DNF-Mesh

```python
class MeshDNFLayer:
    def __init__(self, interface='wlan0'):
        self.routing_protocol = BatmanAdvanced(interface)
        self.fragment_manager = FragmentManager()
        self.quality_monitor = LinkQualityMonitor()

    def send_document(self, mml_document, destination=None):
        """
        Transmission d'un document via le réseau mesh
        """
        # Fragmentation sémantique
        fragments = self.fragment_manager.semantic_split(mml_document)

        # Calcul des routes
        if destination:
            routes = self.calculate_routes(destination, len(fragments))
        else:
            routes = [None] * len(fragments)  # Diffusion

        # Transmission avec redondance
        transmission_tasks = []
        for i, fragment in enumerate(fragments):
            task = self.transmit_fragment(
                fragment,
                route=routes[i],
                redundancy=self.calculate_redundancy(fragment)
            )
            transmission_tasks.append(task)

        # Attente de confirmation
        return self.wait_for_delivery_confirmations(transmission_tasks)

    def maintain_network_topology(self):
        """
        Maintenance continue de la topologie réseau
        """
        while True:
            # Mise à jour des qualités de lien
            self.quality_monitor.update_link_qualities()

            # Détection de nouveaux voisins
            new_neighbors = self.discover_neighbors()

            # Recalcul des routes optimales
            self.routing_protocol.recalculate_routes()

            # Nettoyage des routes obsolètes
            self.clean_obsolete_routes()

            time.sleep(30)  # Maintenance toutes les 30 secondes
```

## Radio amateurs : L'héritage historique revisité

### Le spectre radio comme bien commun

Les bandes radioamateurs (HF, VHF, UHF) offrent des caractéristiques uniques :

#### Propriétés des bandes HF (1.8-30 MHz)
- **Portée mondiale** : Propagation par réflexion ionosphérique
- **Pénétration** : Fonctionne à travers les obstacles et l'obscurité
- **Bande passante limitée** : Idéal pour notre compression extrême
- **Coût énergétique raisonnable** : Accessibles aux équipements portables

#### Propriétés des bandes VHF/UHF (30-470 MHz)
- **Portée locale/régionale** : Ligne de vue avec répétiteurs
- **Bande passante plus large** : Possibilité de modes numériques
- **Interférence urbaine** : Plus affecté par les environnements denses

### Modes de transmission radioamateur intégrés

#### CW (Continuous Wave - Morse)
```
Avantages :
- Simplicité d'implémentation matérielle
- Faible bande passante requise
- Excellente pénétration dans le bruit
- Consommation énergétique minimale

Inconvénients :
- Vitesse limitée (15-40 WPM)
- Saisie manuelle requise pour l'émission
```

#### RTTY (Radio Teletype)
```
Avantages :
- Transmission semi-automatique
- Correction d'erreurs basique
- Vitesse supérieure au CW (60-100 WPM)

Inconvénients :
- Équipement spécialisé requis
- Vulnérable aux interférences
```

#### Packet Radio (AX.25)
```
Avantages :
- Transmission numérique structurée
- Correction d'erreurs avancée
- Routage automatique possible
- Intégration facile avec DNF

Inconvénients :
- Bande passante plus élevée requise
- Complexité accrue
```

### Architecture DNF-Radio

```python
class RadioDNFLayer:
    def __init__(self, radio_interface):
        self.radio = radio_interface
        self.frequency_manager = FrequencyManager()
        self.protocol_selector = ProtocolSelector()
        self.error_corrector = ForwardErrorCorrection()

    def transmit_mml_stream(self, mml_stream, target_station=None):
        """
        Transmission d'un flux MML via radio
        """
        # Sélection du protocole selon les conditions
        protocol = self.select_optimal_protocol()

        # Configuration de fréquence
        frequency = self.frequency_manager.allocate_channel(target_station)

        # Encodage avec correction d'erreurs
        encoded_stream = self.error_corrector.encode(mml_stream)

        # Transmission
        if protocol == 'cw':
            self.transmit_cw(encoded_stream, frequency, wpm=20)
        elif protocol == 'packet':
            self.transmit_packet(encoded_stream, frequency, target_station)
        elif protocol == 'js8call':
            self.transmit_js8call(encoded_stream, frequency)

    def receive_mml_stream(self):
        """
        Réception et décodage de flux MML
        """
        # Écoute sur toutes les fréquences configurées
        for frequency in self.frequency_manager.get_monitored_frequencies():
            raw_signal = self.radio.receive(frequency, timeout=10)

            if raw_signal:
                # Détection automatique du protocole
                protocol = self.protocol_detector.identify(raw_signal)

                # Décodage selon le protocole
                decoded_data = self.decode_signal(raw_signal, protocol)

                # Correction d'erreurs
                corrected_data = self.error_corrector.decode(decoded_data)

                # Reconstruction MML
                mml_fragment = self.reconstruct_mml(corrected_data)

                return mml_fragment

        return None
```

## Intégration multi-technologie : Le meilleur de chaque monde

### Routage inter-technologies

DNF permet la **commutation transparente** entre technologies :

```python
class MultiTechnologyRouter:
    def route_packet(self, packet, destination):
        """
        Routage intelligent selon les capacités de chaque technologie
        """
        available_technologies = self.scan_available_technologies()

        routes = []
        for tech in available_technologies:
            if self.can_reach_destination(tech, destination):
                route = self.calculate_route(tech, destination, packet)
                routes.append(route)

        # Sélection de la meilleure route
        best_route = self.select_optimal_route(routes, packet.priority)

        # Transmission
        return self.transmit_via_route(packet, best_route)

    def select_optimal_route(self, routes, priority):
        """
        Sélection basée sur les métriques temps/coût/fiabilité
        """
        if priority == 'emergency':
            # Priorité à la fiabilité et vitesse
            return min(routes, key=lambda r: r.estimated_delivery_time)
        elif priority == 'bulk':
            # Priorité au débit
            return max(routes, key=lambda r: r.bandwidth)
        else:
            # Équilibre coût/efficacité
            return min(routes, key=lambda r: r.cost_per_bit)
```

### Exemples de scénarios hybrides

#### Transmission d'urgence internationale
```
Téléphone satellite → Internet → Radio HF → Réseau mesh local → Destinataire
```

#### Communication communautaire résiliente
```
Bluetooth mesh → WiFi communautaire → Radio VHF → Packet radio → Internet
```

#### Exploration polaire
```
Radio UHF (robot) → Satellite → Radio HF → Centre de contrôle
```

## Défis et solutions de l'intégration

### Gestion de l'hétérogénéité
- **Normalisation des interfaces** : API commune pour toutes les technologies
- **Adaptation de protocole** : Traduction automatique entre couches
- **Synchronisation temporelle** : Horloges distribuées pour l'ordonnancement

### Optimisation énergétique
- **Modes de veille intelligente** : Activation sélective des interfaces
- **Calcul distribué** : Traitement local pour réduire les transmissions
- **Compression adaptative** : Ajustement selon la bande passante disponible

### Sécurité dans les environnements ouverts
- **Chiffrement de bout en bout** : Protection des données en transit
- **Authentification distribuée** : Vérification sans autorité centrale
- **Détection d'intrusion** : Surveillance des anomalies réseau

## Conclusion : Vers une connectivité ubiquitaire

La transmission hors-réseau ne se limite plus aux amateurs de radio ou aux situations d'urgence. Elle représente une **alternative viable et complémentaire** aux infrastructures centralisées.

Notre système DNF transforme cette contrainte en atout : au lieu de dépendre d'infrastructures fragiles, nous créons des réseaux qui **s'adaptent, survivent, et communiquent** dans n'importe quelles conditions.

Comme les espèces qui prospèrent dans les environnements hostiles, nos protocoles de transmission hors-réseau évoluent pour exploiter les niches laissées vacantes par les technologies traditionnelles. Ils ne remplacent pas Internet ; ils l'**étendent et le complètent**, créant une connectivité véritablement universelle.
