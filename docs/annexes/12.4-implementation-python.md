# 12.4 Exemple d'implémentation Python : Bibliothèque de référence

## Implémentation complète du système DNF-MML-Morse

Voici une implémentation Python complète et fonctionnelle du système DNF-MML-Morse. Cette bibliothèque de référence démontre tous les concepts présentés dans la documentation.

### Structure du projet

```
dnf_mml_morse/
├── __init__.py           # Interface principale
├── mml/                  # Module MML
│   ├── __init__.py
│   ├── parser.py         # Parser MML
│   ├── validator.py      # Validateur
│   └── compressor.py     # Compression MML-C
├── morse/                # Module Morse
│   ├── __init__.py
│   ├── codec.py          # Codec ASCII/Morse
│   └── optimizer.py      # Optimisation
├── dnf/                  # Module DNF
│   ├── __init__.py
│   ├── network.py        # Gestion réseau
│   └── transmission.py   # Transmission
├── examples/             # Exemples d'usage
└── tests/               # Tests unitaires
```

## Interface principale

```python
# dnf_mml_morse/__init__.py
"""
Système DNF-MML-Morse : Transmission de documents structurés via radio
"""

__version__ = "1.0.0"

from .mml import MMLProcessor
from .morse import MorseCodec
from .dnf import DNFTransmitter

class DNFMMLMorseSystem:
    """
    Système intégré DNF-MML-Morse
    """
    
    def __init__(self, config=None):
        """
        Initialisation du système
        
        Args:
            config (dict): Configuration optionnelle
        """
        self.config = config or self._default_config()
        self.mml_processor = MMLProcessor()
        self.morse_codec = MorseCodec(mode=self.config.get('morse_mode', 'optimized'))
        self.dnf_transmitter = DNFTransmitter(
            transport_type=self.config.get('transport', 'cw'),
            callsign=self.config.get('callsign')
        )
    
    def _default_config(self):
        """Configuration par défaut"""
        return {
            'morse_mode': 'optimized',
            'transport': 'cw',
            'callsign': 'DEMO',
            'compression_level': 'standard',
            'wpm': 20
        }
    
    async def transmit_document(self, document_path, destination=None):
        """
        Transmission complète d'un document
        
        Args:
            document_path (str): Chemin vers le document source
            destination (str): Destinataire (optionnel)
        
        Returns:
            dict: Résultats de la transmission
        """
        # Étape 1 : Chargement et conversion MML
        print("Étape 1 : Conversion en MML...")
        mml_doc = await self.mml_processor.convert_to_mml(document_path)
        print(f"✓ Document converti : {len(mml_doc)} caractères MML")
        
        # Étape 2 : Compression MML-C
        print("Étape 2 : Compression MML-C...")
        compressed = await self.mml_processor.compress_mml(mml_doc)
        print(f"✓ Compression : {compressed['ratio']:.1%} d'économie")
        
        # Étape 3 : Conversion Morse
        print("Étape 3 : Conversion Morse...")
        morse_sequence = self.morse_codec.encode(compressed['content'])
        print(f"✓ Séquence Morse : {len(morse_sequence.split())} symboles")
        
        # Étape 4 : Transmission DNF
        print("Étape 4 : Transmission DNF...")
        transmission_result = await self.dnf_transmitter.transmit(
            morse_sequence, 
            destination=destination
        )
        
        print("✓ Transmission terminée !")
        return {
            'original_size': mml_doc['size'],
            'mml_size': len(mml_doc['content']),
            'compressed_size': len(compressed['content']),
            'morse_symbols': len(morse_sequence.split()),
            'transmission_time': transmission_result.get('duration', 0),
            'fragments_sent': transmission_result.get('fragments', 0)
        }

# Fonction utilitaire pour usage simplifié
async def transmit_document(document_path, destination=None, **config):
    """
    Fonction utilitaire pour transmission rapide
    """
    system = DNFMMLMorseSystem(config)
    return await system.transmit_document(document_path, destination)
```

## Module MML

```python
# dnf_mml_morse/mml/__init__.py
"""
Module de traitement MML (Minimal Markup Language)
"""

from .parser import MMLParser
from .validator import MMLValidator
from .compressor import MMLCompressor

class MMLProcessor:
    """
    Processeur principal pour les documents MML
    """
    
    def __init__(self):
        self.parser = MMLParser()
        self.validator = MMLValidator()
        self.compressor = MMLCompressor()
    
    async def convert_to_mml(self, source_path):
        """
        Conversion d'un document source vers MML
        """
        # Détection du type de fichier
        if source_path.endswith('.html'):
            converter = HTMLToMMLConverter()
        elif source_path.endswith('.md'):
            converter = MarkdownToMMLConverter()
        else:
            converter = TextToMMLConverter()
        
        # Conversion
        with open(source_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        mml_content = await converter.convert(content)
        
        # Validation
        if not self.validator.validate(mml_content):
            raise ValueError("Document MML invalide")
        
        return {
            'content': mml_content,
            'size': len(content),
            'format': source_path.split('.')[-1]
        }
    
    async def compress_mml(self, mml_doc):
        """
        Compression MML → MML-C
        """
        return await self.compressor.compress(mml_doc['content'])
```

### Parser MML

```python
# dnf_mml_morse/mml/parser.py
"""
Parser pour le langage MML
"""

import re
from typing import Dict, List, Any

class MMLParser:
    """
    Parser récursif pour MML
    """
    
    def __init__(self):
        self.element_pattern = re.compile(
            r'#([A-Z][A-Z0-9_]*)(?:\s+([^[\n]*?))?(?:\[([^\]]*)\])?(?:\s*\{(.*?)\})?',
            re.DOTALL
        )
    
    def parse(self, mml_text: str) -> Dict[str, Any]:
        """
        Parse un document MML complet
        
        Args:
            mml_text: Texte MML à parser
            
        Returns:
            Arbre syntaxique abstrait
        """
        lines = mml_text.split('\n')
        root = {'type': 'document', 'children': []}
        
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            if not line:
                i += 1
                continue
            
            # Détection d'indentation
            indent_level = len(lines[i]) - len(line)
            
            # Parsing de l'élément
            element = self._parse_element(line)
            if element:
                # Gestion de l'imbrication
                element['indent'] = indent_level
                root['children'].append(element)
            
            i += 1
        
        # Reconstruction de la hiérarchie
        return self._build_hierarchy(root)
    
    def _parse_element(self, line: str) -> Dict[str, Any]:
        """
        Parse un élément MML individuel
        """
        match = self.element_pattern.match(line)
        if not match:
            return None
        
        tag, content, attributes_str, children_str = match.groups()
        
        element = {
            'tag': tag,
            'content': content.strip() if content else '',
            'attributes': self._parse_attributes(attributes_str) if attributes_str else {},
            'children': []
        }
        
        return element
    
    def _parse_attributes(self, attr_str: str) -> Dict[str, Any]:
        """
        Parse les attributs MML
        """
        attributes = {}
        # Parsing simple clé=valeur
        for attr in attr_str.split(','):
            if '=' in attr:
                key, value = attr.split('=', 1)
                key = key.strip()
                value = value.strip()
                
                # Suppression des guillemets
                if value.startswith('"') and value.endswith('"'):
                    value = value[1:-1]
                
                # Conversion de type
                if value.isdigit():
                    value = int(value)
                elif value in ('true', 'false'):
                    value = value == 'true'
                
                attributes[key] = value
        
        return attributes
    
    def _build_hierarchy(self, root: Dict) -> Dict:
        """
        Reconstruction de la hiérarchie à partir des indentations
        """
        def process_children(elements, start_indent=0):
            result = []
            i = 0
            
            while i < len(elements):
                element = elements[i]
                current_indent = element.get('indent', 0)
                
                if current_indent <= start_indent:
                    break
                
                # Recherche des enfants
                children = []
                i += 1
                while i < len(elements):
                    next_element = elements[i]
                    next_indent = next_element.get('indent', 0)
                    
                    if next_indent <= current_indent:
                        break
                    
                    children.append(next_element)
                    i += 1
                
                # Traitement récursif des enfants
                element['children'] = process_children(children, current_indent)
                element.pop('indent', None)  # Nettoyage
                
                result.append(element)
            
            return result
        
        root['children'] = process_children(root['children'])
        return root
```

### Compresseur MML-C

```python
# dnf_mml_morse/mml/compressor.py
"""
Compresseur MML-C avec tokens et optimisation
"""

from .tokens import TOKEN_DICTIONARY

class MMLCompressor:
    """
    Compresseur MML vers MML-C
    """
    
    def __init__(self):
        self.short_codes = {
            '#P': '!P',
            '#LI': '!I',
            '#STRONG': '!B',
            '#EM': '!E',
            '#H1': '!1',
            '#H2': '!2',
            '#UL': '!U',
            '#LINK': '!L',
            '#IMG': '!M'
        }
    
    async def compress(self, mml_content: str, level='standard') -> Dict[str, Any]:
        """
        Compression complète MML → MML-C
        """
        compressed = mml_content
        
        # Phase 1 : Codes courts
        compressed = self._apply_short_codes(compressed)
        
        # Phase 2 : Tokens lexicaux
        compressed = self._apply_lexical_tokens(compressed)
        
        # Phase 3 : Optimisations structurelles
        compressed = self._optimize_structure(compressed)
        
        # Métriques
        original_size = len(mml_content)
        compressed_size = len(compressed)
        
        return {
            'content': compressed,
            'original_size': original_size,
            'compressed_size': compressed_size,
            'ratio': compressed_size / original_size,
            'level': level
        }
    
    def _apply_short_codes(self, text: str) -> str:
        """Application des codes courts"""
        for long_form, short_form in self.short_codes.items():
            text = text.replace(long_form, short_form)
        return text
    
    def _apply_lexical_tokens(self, text: str) -> str:
        """Application des tokens lexicaux"""
        # Tri par longueur décroissante
        sorted_tokens = sorted(
            TOKEN_DICTIONARY.items(),
            key=lambda x: len(x[0]),
            reverse=True
        )
        
        for word, token in sorted_tokens:
            # Échappement pour éviter confusion
            escaped_token = f"##{token[1:]}"
            text = text.replace(word, escaped_token)
        
        return text
    
    def _optimize_structure(self, text: str) -> str:
        """Optimisations structurelles"""
        # Fusion de paragraphes consécutifs courts
        lines = text.split('\n')
        optimized_lines = []
        
        for line in lines:
            if optimized_lines and self._is_short_paragraph(line) and self._is_short_paragraph(optimized_lines[-1]):
                # Fusion
                optimized_lines[-1] += ' ' + line.replace('!P ', '')
            else:
                optimized_lines.append(line)
        
        return '\n'.join(optimized_lines)
    
    def _is_short_paragraph(self, line: str) -> bool:
        """Détection de paragraphe court"""
        return line.startswith('!P ') and len(line) < 100
```

## Module Morse

```python
# dnf_mml_morse/morse/__init__.py
"""
Module de traitement Morse
"""

from .codec import MorseCodec

class MorseCodec:
    """
    Codec ASCII ↔ Morse optimisé pour MML-C
    """
    
    def __init__(self, mode='optimized'):
        self.mode = mode
        self.ascii_to_morse = self._load_ascii_mapping()
        self.morse_to_ascii = self._invert_mapping(self.ascii_to_morse)
    
    def _load_ascii_mapping(self):
        """Chargement du mapping ASCII → Morse"""
        if self.mode == 'optimized':
            return ASCII_TO_MORSE_OPTIMIZED
        else:
            return ASCII_TO_MORSE_STANDARD
    
    def _invert_mapping(self, forward_mapping):
        """Inversion du mapping"""
        inverted = {}
        for char, morse in forward_mapping.items():
            inverted[morse] = char
        return inverted
    
    def encode(self, text: str) -> str:
        """Conversion ASCII → Morse"""
        morse_chars = []
        for char in text:
            ascii_code = ord(char)
            if ascii_code in self.ascii_to_morse:
                morse_chars.append(self.ascii_to_morse[ascii_code])
            else:
                morse_chars.append('•••••')  # Erreur
        
        return ' '.join(morse_chars)
    
    def decode(self, morse_sequence: str) -> str:
        """Conversion Morse → ASCII"""
        text = []
        morse_chars = morse_sequence.split()
        
        for morse_char in morse_chars:
            if morse_char in self.morse_to_ascii:
                text.append(self.morse_to_ascii[morse_char])
            else:
                text.append('?')  # Inconnu
        
        return ''.join(text)

# Mappings (extrait)
ASCII_TO_MORSE_OPTIMIZED = {
    33: '•',        # !
    80: '••',       # P (optimisé pour MML-C)
    73: '•••',      # I (optimisé pour MML-C)
    32: '/',        # Space optimisé
    # ... autres caractères
}

ASCII_TO_MORSE_STANDARD = {
    65: '•─',       # A (standard ITU)
    66: '─•••',     # B
    # ... autres caractères standard
}
```

## Module DNF

```python
# dnf_mml_morse/dnf/__init__.py
"""
Module de transmission DNF (Distributed Network Framework)
"""

import asyncio
from typing import Dict, Any

class DNFTransmitter:
    """
    Émetteur DNF pour transmission radio
    """
    
    def __init__(self, transport_type='cw', callsign='DEMO'):
        self.transport_type = transport_type
        self.callsign = callsign
        self.transport = self._initialize_transport()
    
    def _initialize_transport(self):
        """Initialisation du transport selon le type"""
        if self.transport_type == 'cw':
            return CWTransport(callsign=self.callsign)
        elif self.transport_type == 'js8call':
            return JS8CallTransport(callsign=self.callsign)
        elif self.transport_type == 'packet':
            return PacketTransport(callsign=self.callsign)
        else:
            raise ValueError(f"Transport non supporté: {self.transport_type}")
    
    async def transmit(self, morse_sequence: str, destination=None) -> Dict[str, Any]:
        """
        Transmission d'une séquence Morse via DNF
        """
        # Fragmentation
        fragments = self._fragment_morse_sequence(morse_sequence)
        
        # Transmission de chaque fragment
        transmission_tasks = []
        for fragment in fragments:
            task = self._transmit_fragment(fragment, destination)
            transmission_tasks.append(task)
        
        # Attente des résultats
        results = await asyncio.gather(*transmission_tasks, return_exceptions=True)
        
        # Analyse des résultats
        successful = sum(1 for r in results if not isinstance(r, Exception))
        
        return {
            'fragments': len(fragments),
            'successful': successful,
            'failed': len(fragments) - successful,
            'duration': sum(r.get('duration', 0) for r in results if isinstance(r, dict))
        }
    
    def _fragment_morse_sequence(self, morse_sequence: str) -> List[str]:
        """
        Découpage de la séquence Morse en fragments transmissibles
        """
        # Logique de fragmentation selon le transport
        max_length = self.transport.max_fragment_length()
        
        words = morse_sequence.split()
        fragments = []
        current_fragment = []
        current_length = 0
        
        for word in words:
            word_length = len(word) + 1  # +1 pour l'espace
            
            if current_length + word_length > max_length and current_fragment:
                fragments.append(' '.join(current_fragment))
                current_fragment = [word]
                current_length = word_length
            else:
                current_fragment.append(word)
                current_length += word_length
        
        if current_fragment:
            fragments.append(' '.join(current_fragment))
        
        return fragments
    
    async def _transmit_fragment(self, fragment: str, destination) -> Dict[str, Any]:
        """
        Transmission d'un fragment individuel
        """
        return await self.transport.transmit_fragment(fragment, destination)

# Classes de transport (interfaces simplifiées)
class CWTransport:
    def max_fragment_length(self): return 50  # Caractères Morse
    
    async def transmit_fragment(self, fragment, destination):
        # Simulation de transmission CW
        await asyncio.sleep(0.1)  # Délai simulé
        return {'duration': len(fragment) * 0.05}  # 50ms par caractère

class JS8CallTransport:
    def max_fragment_length(self): return 13  # Limite JS8Call
    
    async def transmit_fragment(self, fragment, destination):
        await asyncio.sleep(0.5)  # 500ms pour JS8Call
        return {'duration': 0.5}

class PacketTransport:
    def max_fragment_length(self): return 200  # Octets AX.25
    
    async def transmit_fragment(self, fragment, destination):
        await asyncio.sleep(0.2)  # 200ms pour packet
        return {'duration': 0.2}
```

## Exemple d'usage complet

```python
# examples/transmit_document.py
"""
Exemple complet de transmission d'un document
"""

import asyncio
from dnf_mml_morse import transmit_document

async def main():
    """
    Exemple de transmission d'un document HTML
    """
    # Transmission d'un document
    result = await transmit_document(
        document_path='examples/sample.html',
        destination='F6XYZ',
        transport='cw',
        morse_mode='optimized',
        wpm=20
    )
    
    print("Transmission terminée !")
    print(f"Taille originale : {result['original_size']} octets")
    print(f"Taille MML : {result['mml_size']} caractères")
    print(f"Taille compressée : {result['compressed_size']} caractères")
    print(f"Symboles Morse : {result['morse_symbols']}")
    print(f"Durée de transmission : {result['transmission_time']:.1f} secondes")
    print(f"Fragments envoyés : {result['fragments_sent']}")

if __name__ == '__main__':
    asyncio.run(main())
```

## Tests unitaires

```python
# tests/test_mml.py
"""
Tests pour le module MML
"""

import pytest
from dnf_mml_morse.mml import MMLProcessor

class TestMMLProcessor:
    
    def setup_method(self):
        self.processor = MMLProcessor()
    
    def test_simple_paragraph(self):
        """Test de conversion de paragraphe simple"""
        html = "<p>Ceci est un test</p>"
        result = self.processor.convert_to_mml(html)
        
        expected = "#P Ceci est un test"
        assert result['content'] == expected
    
    def test_heading_conversion(self):
        """Test de conversion de titres"""
        html = "<h1>Titre principal</h1><h2>Sous-titre</h2>"
        result = self.processor.convert_to_mml(html)
        
        expected = "#H1 Titre principal\n#H2 Sous-titre"
        assert result['content'] == expected
    
    def test_compression(self):
        """Test de compression MML-C"""
        mml = "#P Ceci est un paragraphe de test"
        result = self.processor.compress_mml({'content': mml})
        
        # Vérification que la compression réduit la taille
        assert result['compressed_size'] <= result['original_size']
        assert 'ratio' in result

# tests/test_morse.py
"""
Tests pour le module Morse
"""

from dnf_mml_morse.morse import MorseCodec

class TestMorseCodec:
    
    def setup_method(self):
        self.codec = MorseCodec(mode='optimized')
    
    def test_basic_encoding(self):
        """Test d'encodage de base"""
        text = "E"
        morse = self.codec.encode(text)
        assert morse == "•"
    
    def test_mmlc_frequent_chars(self):
        """Test des caractères fréquents en MML-C"""
        text = "!P"
        morse = self.codec.encode(text)
        assert morse == "• ••"
    
    def test_round_trip(self):
        """Test de conversion aller-retour"""
        original = "!P Hello MML-C"
        morse = self.codec.encode(original)
        reconstructed = self.codec.decode(morse)
        
        assert reconstructed == original
    
    def test_space_handling(self):
        """Test de gestion des espaces"""
        text = "A B"
        morse = self.codec.encode(text)
        reconstructed = self.codec.decode(morse)
        
        assert reconstructed == "A B"

# Exécution des tests
if __name__ == '__main__':
    pytest.main([__file__])
```

## Documentation et exemples

### README du projet

```markdown
# DNF-MML-Morse

Système de transmission de documents structurés via radio amateur utilisant MML (Minimal Markup Language) et le protocole DNF (Distributed Network Framework).

## Installation

```bash
pip install dnf-mml-morse
```

## Usage rapide

```python
import asyncio
from dnf_mml_morse import transmit_document

async def main():
    result = await transmit_document('document.html', destination='F6XYZ')
    print(f"Transmission réussie : {result['fragments_sent']} fragments")

asyncio.run(main())
```

## Fonctionnalités

- ✅ Conversion automatique HTML/Markdown → MML
- ✅ Compression MML-C avec tokens lexicaux
- ✅ Mapping Morse optimisé pour MML-C
- ✅ Transmission CW, JS8Call, Packet Radio
- ✅ Réseau DNF décentralisé
- ✅ Sécurité avec signatures et hash
- ✅ Interface Python complète

## Architecture

```
Document → MML → Compression → Morse → Transmission
   ↑         ↑         ↑          ↑         ↑
   HTML     Parser   Tokens     Codec     DNF
```

## Licence

MIT License - Voir LICENSE pour plus de détails.
```

Cette implémentation fournit une base solide et extensible pour le système DNF-MML-Morse, démontrant tous les concepts présentés dans la documentation de manière pratique et testable.
