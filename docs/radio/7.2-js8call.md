# 7.2 JS8Call : Transmission numérique faible puissance

## JS8Call : La révolution numérique du Morse

### Origines et philosophie

JS8Call est un mode de communication numérique développé par Joe Taylor (K1JT), créateur des célèbres logiciels WSJT-X pour la radio faible signal. Lancé en 2018, JS8Call combine la **robustesse du Morse** avec les **avantages du numérique**, permettant des communications bidirectionnelles fiables à des puissances extrêmement faibles.

Dans notre écosystème DNF-MML-Morse, JS8Call représente le **pont entre tradition et modernité** : utilisant des séquences inspirées du Morse tout en offrant les bénéfices du traitement numérique.

## Principes techniques de JS8Call

### Modulation et codage

#### Structure du signal

JS8Call utilise une **modulation FSK (Frequency Shift Keying)** à 8 tons, d'où son nom. Chaque symbole transporte 3 bits d'information :

- **Fréquence centrale** : 1000-2000 Hz (audio)
- **Décalage** : 6.25 Hz entre tons adjacents
- **Durée symbole** : 160 ms (vitesse fixe)
- **Taille bloc** : 50 bits par transmission (environ 6 secondes)

#### Codage de canal

**Convolutional coding** avec :
- **Taux de code** : 1/2 (chaque bit d'information devient 2 bits transmis)
- **Contraintes** : K=32 (mémoire du codeur)
- **Interleaving** : Protection contre les fades courts

#### Détection et décodage

**Algorithmes avancés** :
- **Corrélation croisée** : Détection précise des signaux faibles
- **Décodage soft** : Utilisation des amplitudes partielles
- **Itérations multiples** : Amélioration progressive de la décodage

### Performances remarquables

#### Rapport S/N minimal

JS8Call peut décoder des signaux avec un **rapport S/N de -28 dB** :
- **Comparaison** : SSB nécessite +10 dB minimum
- **Équivalent** : Signal 600 fois plus faible que le bruit
- **Distance** : Communications intercontinentales à 1 watt

#### Vitesse de transmission

- **Mode normal** : 12.5 caractères par minute
- **Mode turbo** : 25 caractères par minute
- **Latence** : 15-30 secondes par échange (bidirectionnel)

#### Robustesse

- **Résistance aux interférences** : Excellente isolation
- **Tolérance aux fades** : Interleaving profond
- **Rejets des signaux parasites** : Filtrage numérique avancé

## Intégration DNF-MML avec JS8Call

### Architecture d'intégration

#### Pipeline DNF → JS8Call

```python
class DNFJS8CallBridge:
    def __init__(self, js8call_interface):
        self.js8call = js8call_interface
        self.fragmenter = DNFFragmenter()
        self.encoder = JS8CallEncoder()

    def transmit_dnf_content(self, mml_content, destination_callsign):
        """
        Transmission de contenu MML via JS8Call
        """
        # Fragmentation pour JS8Call (limite 50 bits)
        fragments = self.fragmenter.create_js8call_fragments(mml_content)

        # Encodage en format JS8Call
        js8call_packets = []
        for fragment in fragments:
            packet = self.encoder.encode_fragment(fragment)
            js8call_packets.append(packet)

        # Transmission séquentielle
        for packet in js8call_packets:
            self.js8call.transmit_packet(packet, destination_callsign)

        return len(js8call_packets)
```

#### Format des paquets DNF-JS8Call

**Structure d'un paquet** :
```
DNF/[SEQ]/[TOTAL]/[CHECKSUM]/[CONTENT]
```

**Exemple** :
```
DNF/1/3/A1B2/!1 Guide médical d'urgence
DNF/2/3/C3D4/!P Premiers secours essentiels
DNF/3/3/E5F6/CHK G7H8
```

### Optimisations spécifiques

#### Taille des fragments

**Contraintes JS8Call** :
- **Limite absolue** : 13 caractères ASCII par transmission
- **Après codage** : ~50 bits utiles
- **Avec en-tête DNF** : ~8-10 caractères de contenu

**Stratégie de fragmentation** :
```python
def optimize_fragment_size(self, content_size):
    """
    Calcul de la taille optimale de fragment
    """
    # En-tête DNF : "DNF/X/Y/ZZZZ/"
    header_size = 12  # Caractères

    # Checksum : 4 caractères
    checksum_size = 4

    # Marge de sécurité
    margin = 2

    # Taille disponible pour le contenu
    available = 13 - header_size - checksum_size - margin

    return max(available, 1)  # Minimum 1 caractère
```

#### Gestion des accusés de réception

**Mode bidirectionnel** :
1. **Transmission** : Envoi du fragment
2. **Attente** : 15-30 secondes pour accusé
3. **Confirmation** : Vérification de réception
4. **Retransmission** : En cas d'échec

**Messages d'acquittement** :
- `ACK/1` : Fragment 1 reçu correctement
- `NAK/2` : Fragment 2 à retransmettre
- `RST` : Redémarrage de la transmission

## Modes de fonctionnement

### Mode QSO (conversation normale)

#### Utilisation standard

- **Vitesse** : 12.5 caractères/minute
- **Échange** : Alternance automatique émetteur/récepteur
- **Distance** : Mondiale avec puissance faible
- **Fiabilité** : Correction d'erreurs intégrée

#### Exemple de session

```
Station A : DNF/1/2/ABC1/!1 Guide urgence
Station B : ACK/1
Station A : DNF/2/2/DEF2/!P Contenu...
Station B : ACK/2
```

### Mode Bulletin (diffusion unidirectionnelle)

#### Transmission de masse

- **Cible** : Diffusion à toutes les stations à portée
- **Accusés** : Optionnels, statistiques de réception
- **Volume** : Idéal pour bulletins d'information
- **Robustesse** : Répétition automatique

### Mode Relay (réseau maillé)

#### Routage automatique

- **Nœuds intermédiaires** : Stations relais volontaires
- **Découverte automatique** : Topologie réseau dynamique
- **Optimisation** : Chemins les plus fiables
- **Redondance** : Multiples chemins de transmission

## Performances pratiques

### Métriques de terrain

#### Portée et puissance

**Conditions typiques** :
- **1 watt HF** : 500-2000 km selon les bandes
- **5 watts VHF** : 50-200 km
- **Propagation** : Utilise les mêmes bandes que le CW

#### Taux de réussite

**Statistiques réelles** :
- **QSO réussi** : >95% avec S/N > -20 dB
- **Décodage partiel** : 80% avec S/N > -25 dB
- **Échec total** : <5% avec S/N < -28 dB

### Comparaison avec autres modes

| Mode | Puissance min | Vitesse | Portée | Complexité |
|------|---------------|---------|--------|------------|
| CW | 5W | 15 char/min | Mondiale | Faible |
| SSB | 10W | Illimitée | Régionale | Moyenne |
| JS8Call | 1W | 12.5 char/min | Mondiale | Moyenne |
| FT8 | 1W | 13 char/min | Mondiale | Élevée |
| Packet | 5W | 100+ char/min | Locale | Élevée |

## Applications dans DNF-MML

### Transmission de documents structurés

#### Avantages pour MML-C

1. **Correction d'erreurs** : Protection automatique des données
2. **Fiabilité** : Transmission réussie même dans de mauvaises conditions
3. **Bidirectionnel** : Accusés de réception et retransmissions
4. **Faible puissance** : Idéal pour équipements portables

#### Cas d'usage typiques

**Réseau d'urgence** :
- **Fragments vitaux** : Informations médicales prioritaires
- **Confirmation** : Accusés obligatoires pour données critiques
- **Redondance** : Transmission multiple pour fiabilité

**Communication clandestine** :
- **Puissance faible** : Discrétion maximale
- **Robustesse** : Résistance aux brouillages
- **Routage** : Transmission via nœuds intermédiaires

### Implémentation concrète

#### Interface logicielle

```python
class JS8CallInterface:
    def __init__(self, udp_port=2333):
        self.socket = UDPSocket('localhost', udp_port)
        self.buffer = MessageBuffer()

    def transmit_fragment(self, fragment, destination):
        """
        Transmission d'un fragment via JS8Call
        """
        # Formatage du message
        message = f"DNF/{fragment.seq}/{fragment.total}/{fragment.checksum}/{fragment.content}"

        # Envoi via UDP vers JS8Call
        self.socket.send({
            'type': 'TX.TXT',
            'text': message,
            'to': destination
        })

    def receive_messages(self):
        """
        Réception des messages entrants
        """
        while True:
            data = self.socket.receive()
            if data['type'] == 'RX.TXT':
                message = self.parse_incoming_message(data['text'])
                self.process_dnf_message(message)

    def process_dnf_message(self, message):
        """
        Traitement d'un message DNF entrant
        """
        if message.type == 'ACK':
            self.confirm_fragment_delivery(message.seq)
        elif message.type == 'NAK':
            self.retransmit_fragment(message.seq)
        elif message.type == 'DNF':
            self.receive_dnf_fragment(message)
```

## Défis et optimisations

### Gestion de la latence

#### Temps d'échange

**Latence inhérente** :
- **Transmission** : 6 secondes par paquet
- **Propagation** : 0.1-0.5 secondes selon distance
- **Décodage** : 10-20 secondes côté récepteur
- **Réponse** : 15-30 secondes total

**Optimisations** :
- **Paquets plus courts** : Réduction du temps de transmission
- **Mode turbo** : Double vitesse quand conditions permettent
- **Transmission anticipée** : Envoi du prochain paquet pendant décodage

### Gestion des collisions

#### Accès multiple

**Problème** : Plusieurs stations transmettent simultanément

**Solutions JS8Call** :
- **Slots temporels** : Transmission dans des créneaux définis
- **Détection de collision** : Algorithmes de backoff
- **Priorisation** : Stations avec meilleures conditions prioritaires

### Interopérabilité

#### Compatibilité avec autres modes

**Passerelles automatiques** :
- **JS8Call → CW** : Conversion pour stations legacy
- **JS8Call → Packet** : Transmission numérique haute vitesse
- **JS8Call → Satellite** : Routage vers orbite

## Évolution et communauté

### Développement actif

#### Mises à jour régulières

**Améliorations continues** :
- **Modes plus rapides** : JS8Call Turbo
- **Correction d'erreurs étendue** : Robustesse accrue
- **Interfaces améliorées** : Intégration avec autres logiciels

#### Communauté mondiale

**Adoption** :
- **Radioamateurs** : 10,000+ utilisateurs actifs
- **Urgence** : Intégration dans réseaux de secours
- **Expédition** : Communication depuis zones isolées

### Intégration future

#### Vers DNF 2.0

**Évolutions envisagées** :
- **Fragments plus gros** : Avec nouveaux modes
- **Routage intégré** : Topologie réseau automatique
- **Chiffrement** : Sécurité de bout en bout
- **IA** : Optimisation adaptative des transmissions

## Conclusion : L'avenir du numérique faible signal

JS8Call représente une **synthèse parfaite** entre la tradition Morse et la modernité numérique. En permettant des communications fiables à des puissances inimaginables avec les modes analogiques, il ouvre de nouvelles possibilités pour notre système DNF-MML.

Dans un monde où la connectivité devient de plus en plus critique, JS8Call prouve que la **véritable innovation vient souvent de la redécouverte intelligente des principes fondamentaux**, adaptés aux contraintes modernes.

Notre intégration DNF-JS8Call transforme cette technologie de niche en **infrastructure de communication résiliente**, capable de maintenir l'humanité connectée même quand toutes les autres voies de communication ont échoué.
