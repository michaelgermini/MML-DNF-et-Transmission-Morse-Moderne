# 7.1 CW (Morse manual / automatique) : La transmission fondamentale

## CW : Le Morse comme protocole de transport primaire

### Définition et principes

CW (Continuous Wave) désigne la transmission par **ondes entretenues modulées en amplitude** pour produire du code Morse. C'est la méthode la plus fondamentale et universelle de transmission radioamateur, utilisée depuis les premiers jours de la radio.

Dans notre système DNF-MML-Morse, CW constitue le **niveau de transport de base** : simple, robuste, et accessible partout dans le monde.

## Caractéristiques techniques du CW

### Modulation et génération

#### Principe physique

1. **Oscillateur** : Génère une onde porteuse continue (typiquement 1-30 MHz)
2. **Clé de modulation** : Interrompt l'onde selon le code Morse
3. **Antenne** : Rayonne l'onde modulée
4. **Récepteur** : Détecte les interruptions et les convertit en audio

#### Paramètres de transmission

**Fréquence** :
- **Bande HF** (1.8-30 MHz) : Propagation mondiale
- **Bande VHF** (30-300 MHz) : Communication locale/régionale
- **Bande UHF** (300-3000 MHz) : Très courte portée

**Puissance** :
- **QRP** (<5W) : Portatif, faible consommation
- **QRO** (5-100W) : Base station, portée étendue
- **Légale** : Respect des réglementations locales (max 100W en France)

**Vitesse** :
- **5-10 WPM** : Débutant, transmission manuelle lente
- **15-20 WPM** : Radioamateur expérimenté
- **25-40 WPM** : Compétition, transmission automatique

### Implémentation matérielle

#### Émetteur CW basique

```python
class CWTransmitter:
    def __init__(self, frequency, power_watts=5):
        self.frequency = frequency
        self.power = power_watts
        self.keyer_speed = 20  # WPM
        self.ramp_time = 5     # ms (pour éviter les clics)

    def transmit_morse(self, morse_sequence):
        """
        Transmission d'une séquence Morse
        """
        # Configuration de fréquence
        self.set_frequency(self.frequency)

        # Configuration de puissance
        self.set_power(self.power)

        # Transmission séquence par séquence
        for element in self.parse_morse_sequence(morse_sequence):
            if element == '•':
                self.key_down(duration=self.dot_duration())
                self.key_up(duration=self.inter_element_space())
            elif element == '─':
                self.key_down(duration=self.dash_duration())
                self.key_up(duration=self.inter_element_space())
            elif element == '/':
                self.key_up(duration=self.inter_word_space())

    def dot_duration(self):
        """Durée d'un point en millisecondes"""
        return 1200 / self.keyer_speed  # Formule standard

    def dash_duration(self):
        """Durée d'un trait (3 points)"""
        return 3 * self.dot_duration()

    def inter_element_space(self):
        """Espace entre éléments d'une lettre"""
        return self.dot_duration()

    def inter_word_space(self):
        """Espace entre mots"""
        return 7 * self.dot_duration()
```

#### Récepteur CW

**Détection par battement** :
1. **Mélange** : Signal reçu × oscillateur local
2. **Filtrage** : Bande passante étroite (100-500 Hz)
3. **Amplification** : Signal audible
4. **Décodage** : Reconnaissance des patterns point/trait

## Intégration DNF-MML avec CW

### Pipeline de transmission complet

#### Phase 1 : Préparation du contenu

```python
def prepare_dnf_mml_content(content, destination):
    """
    Préparation du contenu pour transmission CW
    """
    # Conversion HTML → MML
    mml_content = HTMLToMMLConverter().convert(content)

    # Compression MML-C
    compressed = MMLCCompressor().compress(mml_content)

    # Conversion MML-C → Morse optimisé
    morse_sequence = MMLCToMorseConverter().convert(compressed)

    # Fragmentation DNF
    fragments = DNFFragmenter().fragment_for_transmission(
        morse_sequence,
        max_duration=300,  # 5 minutes max par fragment
        transport='cw'
    )

    return fragments
```

#### Phase 2 : Transmission CW

```python
def transmit_cw_fragments(fragments, radio_interface):
    """
    Transmission des fragments via CW
    """
    transmitter = CWTransmitter(frequency=7.030e6, power_watts=10)

    for i, fragment in enumerate(fragments):
        # En-tête de synchronisation
        transmitter.transmit_morse("•───•")  # SOF

        # Métadonnées du fragment
        fragment_header = f"#{i+1}/{len(fragments)}"
        transmitter.transmit_morse(text_to_morse(fragment_header))

        # Contenu du fragment
        transmitter.transmit_morse(fragment.content)

        # Checksum et fin
        checksum = calculate_morse_checksum(fragment.content)
        transmitter.transmit_morse(f"CHK{checksum}")
        transmitter.transmit_morse("───•")  # EOF

        # Pause entre fragments (recharge batteries, changement fréquence)
        time.sleep(30)
```

### Optimisations pour CW

#### Adaptation de la vitesse

**Sélection automatique** :
```python
def select_optimal_cw_speed(content_complexity, operator_skill, conditions):
    """
    Sélection de la vitesse CW optimale
    """
    base_speed = 20  # WPM par défaut

    # Ajustements selon les facteurs
    if operator_skill == 'beginner':
        base_speed = min(base_speed, 12)
    elif operator_skill == 'expert':
        base_speed = min(base_speed, 30)

    if conditions['noise'] == 'high':
        base_speed -= 5  # Réduire en cas de bruit

    if content_complexity == 'high':
        base_speed -= 3  # Réduire pour contenu technique

    return max(base_speed, 5)  # Minimum 5 WPM
```

#### Gestion de la fatigue opérateur

**Rotation automatique** :
- **Limite de session** : 30 minutes maximum
- **Pauses obligatoires** : 5 minutes toutes les 15 minutes
- **Rotation d'opérateurs** : Changement automatique
- **Monitoring de performance** : Détection de la fatigue

## Modes de transmission CW

### Transmission manuelle (Straight Key)

#### Avantages
- **Simplicité** : Pas d'équipement électronique complexe
- **Fiabilité** : Aucun risque de panne électronique
- **Formation** : Développement des compétences Morse
- **Urgence** : Fonctionne avec matériel de fortune

#### Inconvénients
- **Vitesse limitée** : 10-15 WPM maximum
- **Fatigue** : Effort physique important
- **Précision** : Variations humaines

#### Utilisation dans DNF
```python
# Transmission manuelle pour situations d'urgence
manual_transmitter = StraightKeyTransmitter()
manual_transmitter.transmit_morse("•───• SOS •───•")  # Signal de détresse
```

### Transmission semi-automatique (Bug Key)

#### Fonctionnement
- **Points automatiques** : Générés mécaniquement
- **Traits manuels** : Produits par l'opérateur
- **Vitesse** : 15-25 WPM
- **Précision** : Très bonne

#### Avantages
- **Vitesse supérieure** : 2x la transmission manuelle
- **Fatigue réduite** : Moins d'effort physique
- **Formation** : Courbe d'apprentissage raisonnable

### Transmission automatique (Electronic Keyer)

#### Technologies modernes

**Keyer électronique** :
- **Microcontrôleur** : Arduino, Raspberry Pi
- **Interface USB** : Connexion ordinateur
- **Logiciel** : Génération automatique du Morse

**Interface radio** :
- **CAT Control** : Contrôle automatique de la fréquence
- **PTT** : Push-To-Talk automatique
- **Monitoring** : Surveillance des signaux

#### Implémentation logicielle

```python
class ElectronicKeyer:
    def __init__(self, serial_port, radio_model='ICOM'):
        self.serial = SerialInterface(serial_port)
        self.radio = RadioInterface(radio_model)
        self.cw_generator = CWGenerator()

    def transmit_dnf_fragment(self, fragment):
        """
        Transmission automatique d'un fragment DNF
        """
        # Configuration radio
        self.radio.set_frequency(fragment.frequency)
        self.radio.set_mode('CW')
        self.radio.set_power(fragment.power)

        # Génération du signal CW
        cw_signal = self.cw_generator.generate_from_morse(fragment.morse_content)

        # Transmission
        self.radio.ptt_on()
        self.serial.send_cw_signal(cw_signal)
        time.sleep(fragment.duration)
        self.radio.ptt_off()

        # Attente acquittement
        acknowledgment = self.wait_for_ack(timeout=30)
        return acknowledgment
```

## Protocoles CW spécialisés

### CW pour DNF : Protocole DNF-CW

#### Structure des transmissions

**Format standard** :
```
[PREAMBLE] [HEADER] [CONTENT] [CHECKSUM] [POSTAMBLE]
```

**Préambule** : `CQ DNF CQ DNF DE [CALLSIGN]`
**En-tête** : Informations de routage DNF
**Contenu** : Fragments MML-C en Morse
**Checksum** : Validation d'intégrité
**Postambule** : `E E` (fin d'émission)

#### Routage CW

**Adresses DNF en CW** :
- **Individuelles** : `F5ABC`
- **Groupe** : `DNF-GROUP-01`
- **Broadcast** : `CQ DNF`
- **Région** : `DNF-EU-WEST`

### Gestion des interférences

#### Évitement des QRM (Interférences)

**Techniques** :
- **Changement de fréquence** : QSY (change frequency)
- **Ajustement de puissance** : Réduction si nécessaire
- **Reprise différée** : Attendre la fin des interférences

#### Coordination réseau

**Protocoles de politesse radio** :
- **QRL?** : Es-tu occupé ?
- **QRX** : Attends (durée en minutes)
- **QRT** : Je termine
- **QSY** : Change de fréquence

## Performance et métriques

### Débit effectif CW

#### Calcul théorique

```
Débit = (caractères_MML-C × bits_par_caractère) / temps_transmission
```

**Exemple à 20 WPM** :
- **1 caractère MML-C** : ~2-3 secondes (moyenne)
- **100 caractères** : ~4 minutes
- **Débit effectif** : ~25 caractères/minute
- **Équivalent bits** : ~200 bits/minute (après compression)

#### Comparaison avec autres modes

| Mode | Débit effectif | Portée | Complexité |
|------|----------------|--------|------------|
| CW manuel | 15-25 char/min | Mondiale | Faible |
| CW automatique | 30-50 char/min | Mondiale | Moyenne |
| RTTY | 60-100 char/min | Régionale | Élevée |
| PSK31 | 50-100 char/min | Régionale | Élevée |

### Optimisations de performance

#### Compression temporelle

**Techniques** :
- **Réduction des espaces** : Espaces inter-lettres minimisés
- **Grouping** : Mots fréquents en séquences optimisées
- **Abbréviations** : Utilisation de Q-codes

#### Amélioration du rapport S/N

**Méthodes** :
- **Antennes directives** : Concentration du signal
- **Puissance adaptée** : Ni trop forte ni trop faible
- **Fréquences optimales** : Choix selon les conditions de propagation

## Applications pratiques

### Radioamateurisme traditionnel

#### Contests et DXing

- **Contests** : Échange rapide d'informations standardisées
- **DXing** : Chasse aux stations lointaines
- **QSO** : Conversations bilatérales

### Communications d'urgence

#### Réseau RACES/ARES

**Réseaux d'urgence** :
- **RACES** (US) : Radio Amateur Civil Emergency Service
- **ARES** : Amateur Radio Emergency Service
- **CDRA** (France) : Civil Defence Radio Amateur

#### Protocoles standardisés

**Formats d'urgence** :
- **ICS-213** : Formulaire standardisé
- **MARS** : Military Affiliate Radio System
- **SHARES** : Shared Resources

### Transmission de données structurées

#### Intégration DNF

**Exemple de transmission** :
```
CQ DNF CQ DNF DE F5ABC
DNF FRAG 1/3 TITLE MEDICAL GUIDE
!1 Guide médical d'urgence
!P Premiers secours essentiels
CHK A1B2
E E
```

## Défis et solutions

### Fatigue opérateur

#### Solutions ergonomiques

- **Ergonomie** : Clés ergonomiques, supports confortables
- **Rotation** : Plusieurs opérateurs
- **Automatisation** : Keyers électroniques pour les longues transmissions

### Conditions de propagation variables

#### Adaptation dynamique

- **Fréquences alternatives** : Passage HF→VHF si nécessaire
- **Puissance variable** : Ajustement selon les conditions
- **Répétition** : Transmission multiple des fragments critiques

### Interopérabilité

#### Standards communs

- **ITU-R M.1677** : Recommandations Morse international
- **IARU** : Union internationale des radioamateurs
- **CEPT** : Conférence européenne des postes et télécommunications

## Évolution technologique

### Intégration moderne

#### Interfaces numériques

**CW via logiciel** :
- **FLDIGI** : Suite logicielle multimode
- **WSJT-X** : Modes faibles signaux
- **Ham Radio Deluxe** : Suite complète de logging

#### Automatisation avancée

**IA et apprentissage** :
- **Reconnaissance automatique** : Décodage Morse par IA
- **Génération adaptative** : Ajustement de vitesse selon l'opérateur
- **Optimisation prédictive** : Choix automatique des fréquences

## Conclusion : CW comme fondation éternelle

Le CW représente la **quintessence de la transmission radioamateur** : simple dans son principe, universel dans son application, éternel dans sa pertinence. Dans notre système DNF-MML-Morse, il constitue le socle sur lequel toutes les autres technologies s'appuient.

Que ce soit pour la transmission manuelle d'urgence ou l'automatisation électronique de précision, le CW prouve que certaines technologies, une fois maîtrisées, transcendent les générations et les révolutions technologiques.

Dans un monde où les bandes passantes se multiplient et les protocoles se complexifient, le CW nous rappelle que la **véritable puissance de communication vient souvent de la simplicité maîtrisée**.
